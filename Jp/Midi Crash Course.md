### MIDIクラッシュコース

MIDI(MusicalInstrument Digital Interface)は音声デバイスの通信において標準的です。
このページはMIDIの簡単な説明をし、その説明はあなたの求める[MixxxのMIDIコントローラーマップ](start)の説明になるでしょう。

MIDIはソフトウェア・ハードウェアともに広く標準的に利用されています。
このデータは1980年代シンセサイザー、サンプラー、そしてシーケンサー同士の通信を目的として作られました。
これらの古いデバイスでは5ピンDINコネクターがMIDI信号を乗せていました。

今日の主なMIDIデバイスはUSBケーブルに乗せて信号を送っています。
いくつかの現在のデバイスは割と5ピンDINケーブルを使って接続しているものもあります。
DJコントローラーはこれらの 5ピンDINコネクターは通常コンピューターに信号を送る際には使いません。
それらはMIDI通信以外の能力としてMIDI以外の情報は送りません（しかし、それらは電源もUSBケーブルから供給することがあります）。

コントローラーは標準USB・MIDIクラスに準拠し（またはデバイスが「クラスに準拠しました」）特別なドライバを必要としません。
ほとんどのコントローラーがUSB・MIDIクラスに準拠しましたが、すべてではありません。
特定のコントローラーに関しては[Mixxx
DJハードウェアガイド](hardware_compatibility)を閲覧してください。

Mixxxの表示は16進数のMIDI信号です。もし見知らぬ16進数があった場合、[このチュートリアル](http://codemastershawn.com/2014/04/03/understanding-binary-and-hex-numbers)を読んでください。

ひとつのMIDI信号の説明について、あなたのコントローラーがコンピューターに信号を送り、
どのような反応をコンピューターはするべきかは、コントローラーのメーカーによるものです。これは製品ページのドキュメントを
これは製作者（メーカー）のコントローラーのWebサイトの製品ページのドキュメントもしくはWebサイトのサポートの項が良いでしょう。
もしそのドキュメントがない場合は、マニュアルの最後に書かれている事があります。
不幸にも、メーカーがこれら全ての情報を提供していないことがあります。

#### MIDIメッセージ

ほとんどのMIDIメッセージは3バイト長です。最初のバイトのMIDIメッセージのほとんどは **状態** を呼ぶバイトです。
最初のニブルはオペレーションコードで、2番目はMIDIチャンネル番号です。たとえば、もしあなたが
0x90 という信号を得たなら、オペレーションコードは `0x9` で、チャンネル番号は `0x0` （チャンネル1)となります。
全てのMIDIメッセージは以下になり、 *n* はチャンネル番号（0〜F)が入ります。

| 状態         | 機能                    | データバイト       |            |
| ---------- | --------------------- | ------------ | ---------- |
| **0x8*n*** | **ノート切**              | **ノート番号**    | **ノートの速さ** |
| **0x9*n*** | **ノート入**              | **ノート番号**    | **ノートの速さ** |
| 0xAn       | 多声・アフタータッチ            | ノート番号        | プレッシャー値    |
| **0xB*n*** | **コントロール／モード変更**      | **コントロール番号** | 値          |
| 0xCn       | プログラム変更               | プログラム番号      | （値なし）      |
| 0xDn       | プログラム・アフタータッチ         | プログラム番号      | （値なし）      |
| **0xE*n*** | **ピッチベンド**            | **最下位バイト**   | **最上位バイト** |
| 0xF0       | システムの排他的メッセージ         | ベンダーID       | （データ）      |
| 0xF1       | MIDIタイムコード クオンタイズフレーム | （仕様を見よ）      |            |
| 0xF2       | 演奏位置ポインター             | 最下位バイト       | 最上位バイト     |
| 0xF3       | 楽曲選択                  | 楽曲番号         | （値なし）      |
| 0xF4       | 未定義                   |              |            |
| 0xF5       | 未定義                   |              |            |
| 0xF6       | チューンリクエスト             | （値なし）        |            |
| 0xF7       | エンドオブエクスクルーシブ         | （値なし）        |            |
| 0xF8       | タイミングクロック             | （値なし）        |            |
| 0xF9       | 未定義                   | （値なし）        |            |
| 0xFA       | 先頭から再生                | （値なし）        |            |
| 0xFB       | 停止中からの再生              | （値なし）        |            |
| 0xFC       | 停止                    | （値なし）        |            |
| 0xFD       | 未定義                   | （値なし）        |            |
| 0xFE       | アクティブセンシング            | （値なし）        |            |
| 0xFF       | システムリセット              | （値なし）        |            |

テーブル上の太字表記のメッセージは私達に大きく関係しており、DJコントローラーはこれらの機能のみを使います。あなたがDJコントローラーの助言を求めるときは、あなたはDJコントローラーの機能やLEDと信号やノートやコントロール番号がどのように一致するかを限定する作業をします。
もしあなたのコントローラーのMIDI仕様がノートネームだけで番号がない場合、[このテーブル](http://www.wavosaur.com/download/midi-note-hex.php)を使ってそれらを変換しましょう10進数から16進数に変換するには[コレを使いましょう](http://www.mathsisfun.com/binary-decimal-hexadecimal-converter.html)

（ノート あなたが[MIDIスクリプティング](midi_scripting)でシステムの排他的メッセージを要求する時に使うでしょう。）

#### DJコントローラーのための典型的なMIDIメッセージ使用法

全てのコントローラーを動作させるのは難しいですが、それらにはいくつかパターンがあります。

##### ボタン

\* ボタンを押した時: オペレーションコード `0x9` , 値が `0xf7` \* ボタンを話した時: オペレーションコード `0x9`
, 値が `0x00` \* もしくはオペレーションコード `0x8` , 値が `0x00`

##### 発光ダイオード（LED）

ある場合のボタンの後ろのLEDは、それは例によって操作信号をコントローラーに最初の2バイト（ステータスとノート番号）が送信され、それはコントローラーがボタンを押された時に送られます。
同様に、値のバイトのためにLEDが点灯か消灯のみします。典型的には `0x00` に切り替わると消灯、そして `0x01` か `0x7f`
に切り替わると点灯します。
マルチカラーLEDは、色は典型的に違う値のコントロール信号を送られます。どれがどの色かを特定するには、あなたのコントローラーのMIDI仕様書を読みましょう。もしそれらがなければ
あなたは他のDJソフトウェアのマッピングを見るか、少しの違う値を試してみてください。

##### ノブとスライダー

これらは通常 `0xB` のオペレーションコードをノブの相対的な値（ `0x00` から `0x7F` の間）と送信します。

エンドレス（連続的な）ノブ・エンコーダーは典型的にオペレーションコード `0xB` と値またはエンコーダーの左右（ `0x01` &
`0x7F` もしくは `0x41` & `0x31` ）のどちらかを示します。

##### ジョグホイール、タッチストリップ、プラッター

これらは通常エンドレスノブ・エンコーダーよりも正確に制御され、通常、触れるか離すとボタンとして意図して機能し、スクラッチングの開始や終了を制御します。

#### Mixxxであなたのコントローラーを嗅ぎ取る

初めに、「Preferences」→「MIDI Devices」ウィンドウ下の「MIDI
Learn」機能を試しましょう。これはあなたを助け、機能要素の割当をXMLを手動で編集するよりも素早く行えます。

あいにくいくつかの大手メーカーはコントローラーのMIDI信号情報を提供しません。この場合、あなたはコントローラーがどんな信号を送っているか見ることがMixxxで可能です。たとえ大手メーカーがMIDIドキュメントを提供しても、それは簡単にあなたのコントローラーとMixxxのコントローラーのドキュメントとして見れるでしょう。

\- Mixxxをコマンドプロンプトから –controllerDebug オブションをつけて起動します。例えば:

  - Linux:

<!-- end list -->

``` 
    <code>user@machine:~$ mixxx --controllerDebug</code>
* Windows:
    <code>C:\Program Files\Mixxx>mixxx --controllerDebug</code>
* Mac OS X:
    <code>$ open -a mixxx --args --controllerDebug</code>
```

\- 出力を見ます

  - コンソール出力もしくは [Mixxx.log](troubleshooting#where_is_the_mixxxlog_file)
    ファイルにMixxxが受信した全てのMIDIメッセージが格納されます。
    あなたがコントローラーを操作すると、MIDIコマンドが送られ、スクリーン/ログファイルに記録されます。
    ステータス（最初の）バイトの行と表を比較し、ボタン/スライダー/コントロールがどのような信号を送っているかノートを取りましょう。
  - 例として、あなたがスライダーを動かした時のログを見ます。:

<!-- end list -->

``` 
   <code>
```

Debug: \[...\]: "MIDI ch 1: opcode: B0, ctrl: 2, val: 3D" Debug:
\[...\]: "MIDI ch 1: opcode: B0, ctrl: 2, val: 3A" Debug: \[...\]: "MIDI
ch 1: opcode: B0, ctrl: 2, val: 3D" Debug: \[...\]: "MIDI ch 1: opcode:
B0, ctrl: 2, val: 3B" Debug: \[...\]: "MIDI ch 1: opcode: B0, ctrl: 2,
val: 3C"

``` 
   </code>
```

この実体は、0xB0（ここで [MIDIメッセージ](midi_crash_course#midi_messages)
のテーブルを見て、私達はこれはコントロールチェンジ信号をチャンネル1で行われているとわかります。）を送り、
私達は2番目のバイトが0x02だと把握でき、このコントロール番号を動かし、更に３つ目の項目では操作の値か場所で、あなたは割当の際に意図的にどちらか無視できます。

\- `<control>` ブロックのバイトの値をXMLファイルに追加する。

  - これで最初の2バイトを \<control\> XMLブロックの \<status\>　と \<midino\>
    に割り当てられます。詳細は次のセクションで。

#### 更に他のMIDIツール

##### Linux

コンソールを開き `amidi -l` を実行してください。これで接続されているMIDIデバイスリストがでます。

    Dir Device    Name
    IO  hw:1,0,0  SCS.3d MIDI 1

そしてデータをダンプします。 `amidi -p hw:1,0,0 -d` を実行してください。（hw:1,0,0
はあなたのコントローラーのリストに表示されたデバイスIDに書き換えてください）
このような情報が得れます:

    B0 02 3D
    B0 02 3A
    B0 02 3D
    B0 02 3B
    B0 02 3C

判断するデータがわかります。

amidiは -S
オプションをつけることでMIDI信号をコントローラーに送ることができます。明示的に16進数列で2バイト同士をスペースで区切ります。例えば:

    amidi -p hw:1,0,0 -S "b0 02 7f"

`aseqdump` は同様のプログラムです。しかし、細かいビット情報が16進数で出てきます。:

    $ aseqdump -l
     Port    Client name                      Port name
      0:0    System                           Timer
      0:1    System                           Announce
     14:0    Midi Through                     Midi Through Port-0
     20:0    Tweaker                          Tweaker MIDI 1
     20:1    Tweaker                          Tweaker MIDI 2
    $ aseqdump -p 20:0
    Waiting for data. Press Ctrl+C to end.
    Source  Event                  Ch  Data
     20:0   Note on                 0, note 1, velocity 127
     20:0   Note off                0, note 1
     20:0   Note on                 0, note 2, velocity 127
     20:0   Note off                0, note 2
     20:0   Note on                 0, note 3, velocity 127
     20:0   Note off                0, note 3

##### Windows

[tail.exe](http://tailforwin32.sourceforge.net/)をダウンロードし、[mixxx.log](troubleshooting#where_is_the_mixxxlog_file)の新しく追加された信号を見るか、
`scons msvcdebug=1` を有効にして
\[compiling\_on\_windows|Mixxxをビルド\]し、ビルドした実行ファイルを
–controllerDebug
オブションをつけて実行します。これはコンソールウィンドウが立ち上がり、コントローラーからのMIDI信号を受信すると表示されます。

##### Mac OS X

無料の[MIDI Monitor](http://www.snoize.com/MIDIMonitor/)をダウンロードして実行します。MIDI
MonitorはMac OS XでMIDI信号を色々なフォーマットで表示するツールです。
入出力MIDIストリームを観察でき、メッセージタイプやチャンネルでフィルターをかけることができます。

無料の[MIDISimulator](http://www.macupdate.com/app/mac/35645/midisimulator)をダウンロードして実行します。
MIDISimulatorはMIDIデバイスをピアノやDJコントローラー的にテストするツールです。 これでMIDIイベントを送受信できます。
